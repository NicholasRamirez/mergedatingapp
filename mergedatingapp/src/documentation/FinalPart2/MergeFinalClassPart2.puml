@startuml
skinparam packageStyle rectangle
skinparam classAttributeIconSize 0

'  AUTH PACKAGE
package "auth" {
    class AuthController {
        -auth: AuthService

        +register(req: RegisterRequest): void
        +login(req: LoginRequest): TokenResponse
        +user(authHeader: String): UserResponse
        +logout(authHeader: String): void
    }

    class AuthService {
        -users: UserRepository
        -passwordEncoder: PasswordEncoder
        -tokens: AuthTokenRepository

        +register(req: RegisterRequest): void
        +login(req: LoginRequest): TokenResponse
        +getUserFromToken(authHeader: String): UserResponse
        +logout(authHeader: String): void
    }

    class AuthToken {
        -id: UUID
        -userId: UUID
        -createdAt: Instant
        -expiresAt: Instant
        -revoked: boolean
    }

    interface AuthTokenRepository <<repository>> {
        +findByIdAndRevokedFalse(id: UUID): Optional<AuthToken>
        +deleteByUserId(userId: UUID): void
    }

    package "dto" {
        class LoginRequest <<record>> {
            +username: String
            +password: String
        }

        class RegisterRequest <<record>> {
            +username: String
            +password: String
        }

        class TokenResponse <<record>> {
            +accessToken: String
        }

        class UserResponse <<record>> {
            +userId: UUID
            +username: String
        }
    }
}

'  USERS + ACCOUNT COMMAND API
package "users" {
    class User {
        -id: UUID
        -username: String
        -passwordHash: String
        -createdAt: Instant
    }

    interface UserRepository <<repository>> {
        +findByUsername(username: String): Optional<User>
        +existsByUsername(username: String): boolean
    }

    class AccountCommandService {
        -executor: UserCommandExecutor
        -deleteAccountCommand: DeleteAccountCommand
        -blockUserCommand: BlockUserCommand

        +deleteAccount(userId: UUID): void
        +blockUser(userId: UUID, blockedUserId: UUID): void
    }

    class AccountController {
        -authService: AuthService
        -commands: AccountCommandService

        +deleteMyAccount(authHeader: String): void
        +blockUser(authHeader: String, req: BlockUserRequest): void
    }

    class BlockedUser {
        -id: UUID
        -blockerId: UUID
        -blockedId: UUID
        -createdAt: Instant
    }

    interface BlockedUserRepository <<repository>> {
        +existsByBlockerIdAndBlockedId(blockerId: UUID, blockedId: UUID): boolean
        +deleteByBlockerIdOrBlockedId(blockerId: UUID, blockedId: UUID): void
    }
}

AuthController --> AuthService
AuthService --> UserRepository
AuthService --> AuthTokenRepository
AuthService --> User
AuthService --> AuthToken

AccountController --> AuthService
AccountController --> AccountCommandService

BlockedUser --> User
BlockedUserRepository --> BlockedUser

'  COMMANDS
package "commands" {

    interface UserCommand {
        execute(userId: UUID): void
    }

    class DeleteAccountCommand implements UserCommand {
        -profiles: ProfileRepository
        -photos: PhotoRepository
        -prompts: PromptAnswerRepository
        -seenRepo: SeenCandidateRepository
        -likeRepo: LikeRepository
        -matchRepo: MatchRepository
        -chatRepo: ChatThreadRepository
        -messageRepo: ChatMessageRepository
        -blockedRepo: BlockedUserRepository

        +execute(userId: UUID): void
    }

    class BlockUserCommand {
        -blockedRepo: BlockedUserRepository

        +execute(blockerId: UUID, blockedId: UUID): void
    }

    class UserCommandExecutor {
        +execute(command: UserCommand, userId: UUID): void
    }
}

AccountCommandService --> UserCommandExecutor
UserCommandExecutor --> DeleteAccountCommand
UserCommandExecutor --> BlockUserCommand
UserCommand --> UserCommandExecutor

'  PROFILES
package "profiles" {

    enum GenderType {
        MALE
        FEMALE
        NONBINARY
        OTHER
        UNSPECIFIED
    }

    enum PronounsType {
        HE_HIM
        SHE_HER
        THEY_THEM
        OTHER
        UNSPECIFIED
    }

    enum RelationshipIntentType {
        LONG_TERM
        SHORT_TERM
        FRIENDSHIP
        CASUAL
        UNDECIDED
    }

    class Profile {
        -id: UUID
        -userId: UUID
        -name: String
        -birthday: LocalDate
        -gender: GenderType
        -pronouns: PronounsType
        -relationshipIntent: RelationshipIntentType
        -heightCm: Integer
        -city: String
        -discoverable: boolean
        -lastUpdated: Instant
    }

    class Photo {
        -id: UUID
        -profileId: UUID
        -url: String
        -position: int
    }

    class PromptAnswer {
        -id: UUID
        -profileId: UUID
        -question: String
        -answer: String
    }

    interface ProfileRepository <<repository>> {
        +findByUserId(userId: UUID): Optional<Profile>
        +existsByUserId(userId: UUID): boolean
        +deleteByUserId(userId: UUID): void
    }

    interface PhotoRepository <<repository>> {
        +findByProfileIdOrderByPositionAsc(profileId: UUID): List<Photo>
        +countByProfileId(profileId: UUID): long
        +deleteByProfileId(profileId: UUID): void
    }

    interface PromptAnswerRepository <<repository>> {
        +findByProfileId(profileId: UUID): List<PromptAnswer>
        +countByProfileId(profileId: UUID): long
        +deleteByProfileId(profileId: UUID): void
    }

    class ProfileService {
        -profiles: ProfileRepository
        -photos: PhotoRepository
        -prompts: PromptAnswerRepository

        +getOrCreateForUser(userId: UUID): Profile
        +getMyProfile(userId: UUID): ProfileResponse
        +updateBasics(userId: UUID, req: ProfileUpdateRequest): ProfileResponse
        +addPhoto(userId: UUID, req: PhotoRequest): void
        +removePhoto(userId: UUID, photoId: UUID): void
        +upsertPrompts(userId: UUID, list: List<PromptAnswerRequest>): void
        -recalcDiscoverable(p: Profile): void
    }

    class ProfileController {
        -svc: ProfileService
        -auth: AuthService

        -userIdFromAuth(header: String): UUID
        +user(authHeader: String): ProfileResponse
        +update(authHeader: String, req: ProfileUpdateRequest): ProfileResponse
        +myPhotos(authHeader: String): List<String>
        +addPhoto(authHeader: String, req: PhotoRequest): void
        +deletePhoto(authHeader: String, photoId: UUID): void
        +myPrompts(authHeader: String): List<ProfileResponse.PromptQA>
        +upsertPrompts(authHeader: String, list: List<PromptAnswerRequest>): void
    }

    package "dto" {
        class ProfileUpdateRequest <<record>> {
            +name: String
            +city: String
            +birthday: LocalDate
            +gender: GenderType
            +pronouns: PronounsType
            +relationshipIntent: RelationshipIntentType
            +heightCm: Integer
        }

        class PhotoRequest <<record>> {
            +url: String
            +position: int
        }

        class PromptAnswerRequest <<record>> {
            +question: String
            +answer: String
        }

        class ProfileResponse <<record>> {
            +profileId: UUID
            +userId: UUID
            +name: String
            +birthday: LocalDate
            +gender: GenderType
            +pronouns: PronounsType
            +relationshipIntent: RelationshipIntentType
            +heightCm: Integer
            +city: String
            +discoverable: boolean
            +photos: List<String>
            +prompts: List<PromptQA>
        }

        class PromptQA <<record>> {
            +question: String
            +answer: String
        }

        ProfileResponse "1" o-- "*" PromptQA
    }

    Profile "1" o-- "*" Photo
    Profile "1" o-- "*" PromptAnswer
}

ProfileController --> AuthService
ProfileController --> ProfileService
ProfileService --> ProfileRepository
ProfileService --> PhotoRepository
ProfileService --> PromptAnswerRepository
ProfileService --> Profile
PhotoRepository --> Photo
PromptAnswerRepository --> PromptAnswer

'  DISCOVERY
package "discovery" {

    class SeenCandidate {
        -id: UUID
        -viewerUserId: UUID
        -candidateUserId: UUID
        -decision: Decision
        -seenAt: Instant
    }

    enum Decision {
        NONE
        PASS
        LIKE
    }

    class LikeEntity {
        -id: UUID
        -likerId: UUID
        -likedId: UUID
        -createdAt: Instant
    }

    class Match {
        -id: UUID
        -userA: UUID
        -userB: UUID
        -createdAt: Instant
        -active: boolean
    }

    class ChatThread {
        -id: UUID
        -matchId: UUID
        -createdAt: Instant
        -archived: boolean
    }

    interface SeenCandidateRepository <<repository>> {
        +findByViewerUserIdAndCandidateUserId(viewer: UUID, candidate: UUID): Optional<SeenCandidate>
        +existsByViewerUserIdAndCandidateUserId(viewer: UUID, candidate: UUID): boolean
        +deleteByViewerUserId(viewerUserId: UUID): void
        +deleteByCandidateUserId(candidateUserId: UUID): void
    }

    interface LikeRepository <<repository>> {
        +existsByLikerIdAndLikedId(a: UUID, b: UUID): boolean
        +findByLikerIdAndLikedId(a: UUID, b: UUID): Optional<LikeEntity>
        +deleteByLikerId(likerId: UUID): void
        +deleteByLikedId(likedId: UUID): void
    }

    interface MatchRepository <<repository>> {
        +findByUserAAndUserB(a: UUID, b: UUID): Optional<Match>
        +findByUserAOrUserB(userA: UUID, userB: UUID): List<Match>
        +deleteAll(matches: Iterable): void
    }

    interface ChatThreadRepository <<repository>> {
        +findByMatchId(matchId: UUID): Optional<ChatThread>
        +findAllByMatchId(matchId: UUID): List<ChatThread>
        +deleteAllByMatchId(matchId: UUID): void
    }

    interface CandidateOrderingStrategy {
        +orderCandidates(candidates: List<Profile>, viewerUserId: UUID): List<Profile>
    }

    class LastUpdatedCandidateOrderingStrategy implements CandidateOrderingStrategy {
        +orderCandidates(candidates: List<Profile>, viewerUserId: UUID): List<Profile>
    }

    class DiscoveryService {
        -profiles: ProfileRepository
        -photos: PhotoRepository
        -prompts: PromptAnswerRepository
        -seenRepo: SeenCandidateRepository
        -likeRepo: LikeRepository
        -matchRepo: MatchRepository
        -chatRepo: ChatThreadRepository
        -blockedRepo: BlockedUserRepository
        -candidateOrderingStrategy: CandidateOrderingStrategy
        -events: ApplicationEventPublisher

        +next(viewerUserId: UUID): CandidateCard
        +pass(viewer: UUID, candidate: UUID): void
        +like(liker: UUID, liked: UUID): LikeResponse
    }

    class DiscoveryController {
        -auth: AuthService
        -svc: DiscoveryService

        -uid(header: String): UUID
        +next(authHeader: String): CandidateCard
        +pass(authHeader: String, req: PassRequest): void
        +like(authHeader: String, req: LikeRequest): LikeResponse
    }

    package "events" {
        class MatchCreatedEvent <<record>> {
            +matchId: UUID
            +threadId: UUID
            +userAId: UUID
            +userBId: UUID
            +occurredAt: Instant
        }

        class MatchNotificationListener <<listener>> {
            -notificationFactory: NotificationFactory

            +onMatchCreated(event: MatchCreatedEvent): void
        }
    }

    package "notifications" {

        interface NotificationSender {
            +sendMatchNotification(userA: UUID, userB: UUID, matchId: UUID, threadId: UUID): void
        }

        class ConsoleNotificationSender implements NotificationSender {
            -log: Logger

            +sendMatchNotification(userA: UUID, userB: UUID, matchId: UUID, threadId: UUID): void
        }

        abstract class NotificationFactory {
            +createSenderForUser(userId: UUID): NotificationSender
            +notifyMatch(userA: UUID, userB: UUID, matchId: UUID, threadId: UUID): void
        }

        class DefaultNotificationFactory extends NotificationFactory {
            +createSenderForUser(userId: UUID): NotificationSender
        }
      }

      MatchNotificationListener --> NotificationFactory
      NotificationFactory --> NotificationSender
      DefaultNotificationFactory --|> NotificationFactory
      ConsoleNotificationSender ..|> NotificationSender

    package "dto" {
        class CandidateCard <<record>> {
            +userId: UUID
            +name: String
            +city: String
            +photos: List<String>
            +prompts: List<PromptQA>
            +genderType: GenderType
            +pronounsType: PronounsType
            +relationshipIntent: RelationshipIntentType
            +heightCm: Integer
        }

        class PromptQA <<record>> {
            +question: String
            +answer: String
        }

        class LikeRequest <<record>> {
            +likedUserId: UUID
        }

        class PassRequest <<record>> {
            +candidateUserId: UUID
        }

        class LikeResponse <<record>> {
            +status: String
            +matchId: UUID
            +threadId: UUID
            +liked(): LikeResponse
            +matched(matchId: UUID, threadId: UUID, threadId: UUID): LikeResponse
        }

        CandidateCard "1" o-- "*" PromptQA
    }
}

DiscoveryController --> AuthService
DiscoveryController --> DiscoveryService
DiscoveryService --> ProfileRepository
DiscoveryService --> PhotoRepository
DiscoveryService --> PromptAnswerRepository
DiscoveryService --> SeenCandidateRepository
DiscoveryService --> LikeRepository
DiscoveryService --> MatchRepository
DiscoveryService --> ChatThreadRepository
DiscoveryService --> CandidateOrderingStrategy
DiscoveryService --> MatchCreatedEvent

LastUpdatedCandidateOrderingStrategy -up-|> CandidateOrderingStrategy
MatchNotificationListener ..> MatchCreatedEvent

Match "1" o-- "1" ChatThread

'  CHAT
package "chat" {

    class ChatMessage {
        -id: UUID
        -threadId: UUID
        -senderId: UUID
        -sentAt: Instant
        -content: String
    }

    interface ChatMessageRepository <<repository>> {
        +findByThreadIdOrderBySentAtAsc(threadId: UUID): List<ChatMessage>
        +deleteByThreadId(threadId: UUID): void

    }

    class ChatService {
        -matches: MatchRepository
        -threads: ChatThreadRepository
        -messages: ChatMessageRepository
        -profiles: ProfileRepository
        -blockedRepo: BlockedUserRepository

        +listThreads(userId: UUID): List<ThreadSummary>
        +getMessages(userId: UUID, threadId: UUID): List<MessageResponse>
        +send(userId: UUID, threadId: UUID, req: MessageRequest): MessageResponse
        -ensureParticipant(userId: UUID, t: ChatThread): void
    }

    class ChatController {
        -auth: AuthService
        -svc: ChatService

        -uid(header: String): UUID
        +myThreads(authHeader: String): List<ThreadSummary>
        +getMessages(authHeader: String, threadId: UUID): List<MessageResponse>
        +send(authHeader: String, threadId: UUID, req: MessageRequest): MessageResponse
    }

    package "dto" {
        class MessageRequest <<record>> {
            +content: String
        }

        class MessageResponse <<record>> {
            +id: UUID
            +threadId: UUID
            +senderId: UUID
            +sentAt: Instant
            +content: String
        }

        class ThreadSummary <<record>> {
            +threadId: UUID
            +matchId: UUID
            +partnerUserId: UUID
            +partnerName: String
        }
    }
}

ChatController --> AuthService
ChatController --> ChatService
ChatService --> MatchRepository
ChatService --> ChatThreadRepository
ChatService --> ChatMessageRepository
ChatService --> ProfileRepository
ChatMessageRepository --> ChatMessage
ChatThreadRepository --> ChatThread

'  SECURITY / CONFIG
package "security" {
    class PasswordConfig {
        +passwordEncoder(): PasswordEncoder
    }

    class SecurityConfig {
        +filterChain(http: HttpSecurity): SecurityFilterChain
    }
}

package "config" {
    class CorsConfig {
        +corsFilter(): Object
    }
}

@enduml